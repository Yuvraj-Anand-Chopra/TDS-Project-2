import os
import logging
import json
import re
import base64
import io
from contextlib import redirect_stdout
from typing import Dict
from urllib.parse import urlparse

import requests
import google.generativeai as genai
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, HttpUrl
from dotenv import load_dotenv
from bs4 import BeautifulSoup

# --- CONFIGURATION ---
load_dotenv()

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    logger.warning("GEMINI_API_KEY is missing!")

genai.configure(api_key=GEMINI_API_KEY)

# --- DATA MODELS ---
class QuizRequest(BaseModel):
    email: str
    secret: str
    url: HttpUrl

# --- CORE LOGIC ---
class TaskSolver:
    def __init__(self):
        self.model = genai.GenerativeModel("gemini-2.0-flash")
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }

    def decode_obfuscated_html(self, html_content: str) -> str:
        """Decode base64 encoded HTML content from JavaScript atob()"""
        try:
            matches = re.findall(
                r'atob\([`"\']([A-Za-z0-9+/=\s]+)[`"\']\)',
                html_content
            )
            
            decoded_parts = []
            for match in matches:
                try:
                    clean_match = re.sub(r'\s+', '', match)
                    decoded_bytes = base64.b64decode(clean_match)
                    decoded_str = decoded_bytes.decode('utf-8')
                    decoded_parts.append(decoded_str)
                except Exception as e:
                    logger.warning(f"Failed to decode base64: {e}")

            if decoded_parts:
                return "\n".join(decoded_parts) + "\n" + html_content
            
            return html_content
        except Exception:
            return html_content

    def execute_python_code(self, code: str) -> str:
        """Execute Python code generated by LLM"""
        logger.info("Executing generated Python code...")
        try:
            f = io.StringIO()
            
            import pandas as pd
            import numpy as np
            
            local_vars = {}
            global_vars = {
                "pd": pd,
                "numpy": np,
                "np": np,
                "requests": requests,
                "json": json,
                "print": print
            }

            with redirect_stdout(f):
                exec(code, global_vars, local_vars)
            
            output = f.getvalue().strip()
            return output if output else "Code executed successfully"

        except Exception as e:
            logger.error(f"Code execution failed: {e}")
            return f"Execution Error: {str(e)}"

    def get_llm_answer(self, instruction: str) -> str:
        """Get answer from Gemini LLM"""
        prompt = f"""You are an expert problem solver.

IGNORE all "POST to JSON" instructions and submission format examples.
ONLY solve the actual question asked.

QUESTION:
{instruction}

RULES:
1. If answer is simple: output ONLY the answer value (number/text)
2. If answer needs calculation or data processing:
   - Write Python code
   - Use requests, pandas, numpy as needed
   - Print final answer only
   - Wrap code in ```python and ```

OUTPUT: Just the answer or Python code. Nothing else."""
        
        try:
            response = self.model.generate_content(prompt)
            text = response.text.strip()
            
            # Check for Python code
            if "```python" in text:
                code_match = re.search(r'```python(.*?)```', text, re.DOTALL)
                if code_match:
                    code = code_match.group(1).strip()
                    logger.info("LLM generated Python code")
                    result = self.execute_python_code(code)
                    logger.info(f"Result: {result}")
                    return result.strip()
            
            # Clean up any remaining markdown
            text = re.sub(r'```.*?```', '', text, flags=re.DOTALL).strip()
            return text
            
        except Exception as e:
            logger.error(f"LLM Error: {e}")
            return "Error: Could not get answer"

    def solve_single_step(self, url: str, email: str, secret: str) -> Dict:
        """Solve a single quiz step"""
        logger.info(f"Processing URL: {url}")
        
        try:
            # Fetch page
            resp = requests.get(url, headers=self.headers, timeout=30)
            resp.raise_for_status()
            
            # Decode obfuscated content
            readable_html = self.decode_obfuscated_html(resp.text)
            
            # Extract visible text
            soup = BeautifulSoup(readable_html, 'html.parser')
            visible_text = soup.get_text("\n").strip()
            
            # Get answer from LLM
            answer = self.get_llm_answer(visible_text)
            
            # Clean answer
            answer = str(answer).strip()
            answer = re.sub(r'```.*?```', '', answer, flags=re.DOTALL).strip()
            
            # Try to convert to number if it looks like one
            final_answer = answer
            try:
                if '.' in str(answer):
                    final_answer = float(answer)
                else:
                    final_answer = int(answer)
            except (ValueError, TypeError):
                pass
            
            # Find submission URL
            submit_url = None
            url_match = re.search(
                r'https?://[^\s"\']+/submit',
                readable_html
            )
            if url_match:
                submit_url = url_match.group(0)
            else:
                parsed = urlparse(url)
                submit_url = f"{parsed.scheme}://{parsed.netloc}/submit"
            
            # Extract path for submission
            parsed_url = urlparse(url)
            url_path = parsed_url.path if parsed_url.path else "/demo"
            
            logger.info(f"Answer: {final_answer}")
            logger.info(f"Submitting to: {submit_url}")
            logger.info(f"URL path: {url_path}")
            
            # Submit answer
            payload = {
                "email": email,
                "secret": secret,
                "url": url_path,
                "answer": final_answer
            }
            
            submit_resp = requests.post(submit_url, json=payload, timeout=30)
            
            try:
                return submit_resp.json()
            except:
                return {
                    "error": "Invalid response from server",
                    "status": submit_resp.status_code
                }
                
        except Exception as e:
            logger.error(f"Error in solve_single_step: {e}")
            return {"error": str(e)}

# --- API SETUP ---
app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

solver = TaskSolver()

@app.post("/solve-quiz")
async def solve_quiz_endpoint(request: Request):
    """Main quiz solving endpoint"""
    try:
        body = await request.json()
        req_data = QuizRequest(**body)
    except Exception as e:
        logger.error(f"Invalid request: {e}")
        raise HTTPException(status_code=400, detail="Invalid JSON payload")

    # Validate secret
    EXPECTED_SECRET = os.getenv("SECRET")
    if EXPECTED_SECRET and req_data.secret != EXPECTED_SECRET:
        raise HTTPException(status_code=403, detail="Invalid Secret")

    # Solve quiz
    current_url = str(req_data.url)
    email = req_data.email
    secret = req_data.secret
    
    iteration = 0
    max_iterations = 10
    last_response = {}
    
    while iteration < max_iterations:
        try:
            logger.info(f"--- Iteration {iteration + 1} ---")
            result = solver.solve_single_step(current_url, email, secret)
            last_response = result
            
            # Check if correct and continue
            if isinstance(result, dict) and result.get("correct") is True:
                next_url = result.get("url")
                if next_url:
                    logger.info(f"Correct! Next: {next_url}")
                    current_url = next_url
                    iteration += 1
                    continue
                else:
                    logger.info("Quiz completed!")
                    break
            else:
                logger.warning(f"Answer incorrect or error: {result}")
                break
                
        except Exception as e:
            logger.error(f"Iteration error: {e}")
            return JSONResponse(
                status_code=500,
                content={"error": str(e)}
            )

    return last_response

@app.get("/health")
def health():
    """Health check endpoint"""
    return {"status": "ok", "model": "gemini-2.0-flash"}
